\section{Background on Autoencoder Sytems}

Before delving into the specifics of our problem, it is important to provide a brief background on autoencoder wireless communication systems. As shown in Figure \ref{fig:original_autoencoder_architecture}, these systems use autoencoder neural network designs \cite{baldi2012autoencoders} to enhance the performance of wireless communication systems. Autoencoder-based communication systems are a relatively new development in wireless communications and have numerous advantages, such as their ability to learn from data and adapt to changing conditions in the wireless environment, making them ideal for dynamic wireless environments. They can also be trained to handle noise and errors in the transmitted data, not only for linear, but also for nonlinear channel effects. Autoencoder-based wireless communication systems were introduced as an end-to-end learning paradigm that abstracts the coding and modulation components of traditional modular communication systems by replacing the transmitter and receiver with DNNs. The encoder (transmitter) learns the underlying statistical properties of the wireless channel and accordingly modulates the signal, while the decoder (receiver) receives a noisy version of the signal and attempts to reconstruct the message.

We describe below how this communication works in both single-user and multi-user systems in greater detail.

\textbf{Single-User Autonencoder Systems}: In this type of communication system, the encoder transforms \(k\) bits of data into a message \(s\) where \(s \in \{1,...,M\}\) and \(M = 2^k\). The encoder then takes this transformed message as an input and generates a signal \(X = E(s) \in \mathbb{R}^{2n}\), which is a real-valued vector. This \(2 \times n\)-dimensional real-valued vector can be treated as an \(n\)-dimensional complex vector, where \(n\) is the number of channel uses required for signal transmission. To account for channel noise, usually additive white Gaussian noise (AWGN), the noise effect is added to the signal vector, denoted as \(N \sim \mathcal{CN}(0, \sigma^2)\), where \(\sigma^2\) is the noise's variance. Eventually, the received signal at the receiver, carrying the channel's noise, can be expressed as \(Y = X + N\). If the signal is also subject to fading, we use Rayleigh or Rician fading channels. In these channel models, the received signal is given by \(Y = H \cdot X + N\), where \(H \sim \mathcal{CN}(0, 1)\) is the channel coefficients. After passing through the channel, the decoder receives these distorted signals and applies the transformation \(D: \mathbb{R}^{2n} \rightarrow M \) to output the reconstructed version of the message \(s\), which is  denoted as \(\hat{s} = D(Y)\).

\textbf{Multi-User Autonencoder Systems}: A multi-user autoencoder communication system is just an extended version of a single-user system with either multiple transmitters and receivers or multiple transmitters and a central receiver. In this work, we consider the latter case. In this system, each encoder sends a separate message \(s_i\) where \(s_i \in s\), and \(i\) is the index of the transmitter. Each transmitter generates a modulated signal accordingly: \(X_i = E_i(s_i) \in \mathbb{R}^{2n}\). Since all transmitters send their signals at the same time, the signals experience channel interference in addition to channel effects. In an AWGN channel, interference is calculated by adding signals together. Consequently, the received signal at the receiver for each transmitter, which carries both the noise of the channel and the interference, can be expressed as \(Y_i = \sum_{i=0}^{n_{tx}}X_i + N_i\), where \(n_{tx}\) is the number of transmitters. In Rayleigh or Rician fading channels, signals are simultaneously faded and mixed after being multiplied by the channel matrix. The resulting vector of signals for each transmitter can be expressed as \(Y_i = H_i \cdot X + N_i\), where \(H_i\) is the channel coefficients for the \(i^{th}\) transmitter's signals and \(X\) is a matrix containing all transmitters' encoded signals. \(H\) itself is a matrix of size \(n_{tx} \times n_{rx}\). Finally, the signals are received at the decoder that uses its decoding function \(D(\cdot)\) along with the channel matrix \(H\) to reconstructed the message \(\hat{s} = D(Y, H)\).