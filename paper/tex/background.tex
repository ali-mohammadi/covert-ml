\section{Background on Autoencoder Sytems}

Before proceeding to the details of our problem, we need to provide a brief background on autoencoder wireless communication systems. You can find an overview of an example autoencoder-based wireless system in Figure \ref{fig:original_autoencoder_architecture}.
Autoencoder wireless systems, also known as autoencoder-based communication systems, are a relatively new development in wireless communications. Autoencoder neural network designs \cite{baldi2012autoencoders} are used in these systems to increase the performance of wireless communication systems. One of the main advantages of these systems is their ability to learn from data and adapt to changing conditions in the wireless environment, which makes them well-suited for dynamic wireless environments. They can be trained to handle noise and errors in the transmitted data, not just for the linear, but also for the nonlinear channel effects.
Autoencoder-based wireless communication system was introduced as an end-to-end learning paradigm that abstracts out the coding and the modulation components of the traditional modular communication systems by replacing the transmitter and receiver with DNNs. The encoder (transmitter) learns the underlying statistical properties of the wireless channel and then accordingly modulates the signal. The decoder (receiver), on the other hand, receives a noisy version of the signal and tries to reconstruct this message. 

We describe below how this communication works in both single-user and multi-user systems in more details.

\textbf{Single-User Autonencoder Systems}: The communication starts with the encoder transforming \(k\) bits of data into a message \(s\) where \(s \in \{1,...,M\}\) and \(M = 2^k\). Then the encoder takes this transformed message as an input and generates a signal \(X = E(s) \in \mathbb{R}^{2n}\), which is a real-valued vector. This \(2 \times n\)-dimensional real-valued vector can be treated as an \(n\)-dimensional complex vector where \(n\) is the number of channel uses that are needed for the signal transmission. Then, the channel noise effect, which is usually considered as an additive white Gaussian noise (AWGN), is added to the signal vector. This is denoted as \(N \sim \mathcal{CN}(0, \sigma^2)\), where \(\sigma^2\) is the noise's variance. Eventually, the received signal at the receiver that carries the noise of the channel can be expressed as \(Y = X + N\). We use Rayleigh or Rician fading channels when signals are also subject to fading effect. In these channel models, the received signal is given by \(Y = H \cdot X + N\), where \(H \sim \mathcal{CN}(0, 1)\) is the channel coefficients. After signals pass through the channel, the decoder receives these distorted signals and applies the transformation \(D: \mathbb{R}^{2n} \rightarrow M \) to output the reconstructed version of the message \(s\), which is  denoted as \(\hat{s} = D(Y)\).

\textbf{Multi-User Autonencoder Systems}: A multi-user autoencoder communication system is just an extended version of a single-user system with either multiple transmitters and receivers or multiple transmitters and a central receiver. We consider the latter case in this work. In this system, each encoder sends a separate message \(s_i\) where \(s_i \in s\), and \(i\) is the index of the transmitter. Then, each transmitter accordingly generates the modulated signal \(X_i = E_i(s_i) \in \mathbb{R}^{2n}\). Since all transmitters send their signals at the same time, signals will experience channel interference in addition to the channel effects. In AWGN channel, interference is calculated by adding signals together. Consequently, each transmitter's received signal at the receiver, which is carrying both the noise of the channel and the interference, can be expressed as \(Y_i = \sum_{i=0}^{n_{tx}}X_i + N_i\), where \(n_{tx}\) is the number of transmitters. In Rayleigh or Rician fading channels, signals are simultaneously faded and mixed after being multiplied by the channel matrix. The resulting vector of signals for each transmitter can be expressed as \(Y_i = H_i \cdot X + N_i\), where \(H_i\) is the channel coefficients for the \(i^{th}\) transmitter's signals and \(X\) is a matrix containing all transmitters' encoded signals. \(H\) itself is a matrix of size \(n_{tx} \times n_{rx}\). Finally, the signals are received at the decoder that uses its decoding function \(D(\cdot)\) along with the channel matrix \(H\) to reconstructed the message \(\hat{s} = D(Y, H)\).